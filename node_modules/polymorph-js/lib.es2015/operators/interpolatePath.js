import { renderPath } from './renderPath';
import { EPSILON, abs, floor, min, round } from '../utilities/math';
import { raiseError } from '../utilities/errors';
import { normalizePaths } from './normalizePaths';
import { fillObject } from '../utilities/objects';
import { createNumberArray } from '../utilities/createNumberArray';
import { FILL } from '../constants';
const defaultOptions = {
    addPoints: 0,
    optimize: FILL,
    origin: { x: 0, y: 0 },
    precision: 0
};
export function interpolatePath(paths, options) {
    options = fillObject(options, defaultOptions);
    if (!paths || paths.length < 2) {
        raiseError('invalid arguments');
    }
    const hlen = paths.length - 1;
    const items = Array(hlen);
    for (let h = 0; h < hlen; h++) {
        items[h] = getPathInterpolator(paths[h], paths[h + 1], options);
    }
    const formatter = !options.precision ? round : (n) => n.toFixed(options.precision);
    return (offset) => {
        const d = hlen * offset;
        const flr = min(floor(d), hlen - 1);
        return renderPath(items[flr]((d - flr) / (flr + 1)), formatter);
    };
}
function getPathInterpolator(left, right, options) {
    const matrix = normalizePaths(left, right, options);
    const n = matrix[0].length;
    return (offset) => {
        if (abs(offset - 0) < EPSILON) {
            return left.path;
        }
        if (abs(offset - 1) < EPSILON) {
            return right.path;
        }
        const results = Array(n);
        for (let h = 0; h < n; h++) {
            results[h] = mixPoints(matrix[0][h], matrix[1][h], offset);
        }
        return results;
    };
}
export function mixPoints(a, b, o) {
    const alen = a.length;
    const results = createNumberArray(alen);
    for (let i = 0; i < alen; i++) {
        results[i] = a[i] + (b[i] - a[i]) * o;
    }
    return results;
}
