Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = require("../constants");
var coalesce_1 = require("../utilities/coalesce");
var errors_1 = require("../utilities/errors");
var math_1 = require("../utilities/math");
var arcToCurve_1 = require("./arcToCurve");
var argLengths = { M: 2, H: 1, V: 1, L: 2, Z: 0, C: 6, S: 4, Q: 4, T: 2, A: 7 };
function addCurve(ctx, x1, y1, x2, y2, dx, dy) {
    var x = ctx.x;
    var y = ctx.y;
    ctx.x = coalesce_1.coalesce(dx, x);
    ctx.y = coalesce_1.coalesce(dy, y);
    ctx.p.push(coalesce_1.coalesce(x1, x), (y1 = coalesce_1.coalesce(y1, y)), (x2 = coalesce_1.coalesce(x2, x)), (y2 = coalesce_1.coalesce(y2, y)), ctx.x, ctx.y);
    ctx.lc = ctx.c;
}
function convertToAbsolute(ctx) {
    var c = ctx.c;
    var t = ctx.t;
    var x = ctx.x;
    var y = ctx.y;
    if (c === constants_1.V) {
        t[0] += y;
    }
    else if (c === constants_1.H) {
        t[0] += x;
    }
    else if (c === constants_1.A) {
        t[5] += x;
        t[6] += y;
    }
    else {
        for (var j = 0; j < t.length; j += 2) {
            t[j] += x;
            t[j + 1] += y;
        }
    }
}
function parseSegments(d) {
    return d
        .replace(/[\^\s]*([mhvlzcsqta]|\-?\d*\.?\d+)[,\$\s]*/gi, ' $1')
        .replace(/([mhvlzcsqta])/gi, ' $1')
        .trim()
        .split('  ')
        .map(parseSegment);
}
function parseSegment(s2) {
    return s2.split(constants_1.EMPTY).map(parseCommand);
}
function parseCommand(str, i) {
    return i === 0 ? str : +str;
}
function parsePoints(d) {
    var ctx = {
        x: 0,
        y: 0,
        s: []
    };
    var segments = parseSegments(d);
    for (var i = 0; i < segments.length; i++) {
        var terms = segments[i];
        var commandLetter = terms[0];
        var command = commandLetter.toUpperCase();
        var isRelative = command !== constants_1.Z && command !== commandLetter;
        ctx.c = command;
        var maxLength = argLengths[command];
        var t2 = terms;
        var k = 1;
        do {
            ctx.t = t2.length === 1 ? t2 : t2.slice(k, k + maxLength);
            if (isRelative) {
                convertToAbsolute(ctx);
            }
            var n = ctx.t;
            var x = ctx.x;
            var y = ctx.y;
            var x1 = void 0, y1 = void 0, dx = void 0, dy = void 0, x2 = void 0, y2 = void 0;
            if (command === constants_1.M) {
                ctx.s.push((ctx.p = [(ctx.x = n[0]), (ctx.y = n[1])]));
            }
            else if (command === constants_1.H) {
                addCurve(ctx, constants_1._, constants_1._, constants_1._, constants_1._, n[0], constants_1._);
            }
            else if (command === constants_1.V) {
                addCurve(ctx, constants_1._, constants_1._, constants_1._, constants_1._, constants_1._, n[0]);
            }
            else if (command === constants_1.L) {
                addCurve(ctx, constants_1._, constants_1._, constants_1._, constants_1._, n[0], n[1]);
            }
            else if (command === constants_1.Z) {
                addCurve(ctx, constants_1._, constants_1._, constants_1._, constants_1._, ctx.p[0], ctx.p[1]);
            }
            else if (command === constants_1.C) {
                addCurve(ctx, n[0], n[1], n[2], n[3], n[4], n[5]);
                ctx.cx = n[2];
                ctx.cy = n[3];
            }
            else if (command === constants_1.S) {
                var isInitialCurve = ctx.lc !== constants_1.S && ctx.lc !== constants_1.C;
                x1 = isInitialCurve ? constants_1._ : x * 2 - ctx.cx;
                y1 = isInitialCurve ? constants_1._ : y * 2 - ctx.cy;
                addCurve(ctx, x1, y1, n[0], n[1], n[2], n[3]);
                ctx.cx = n[0];
                ctx.cy = n[1];
            }
            else if (command === constants_1.Q) {
                var cx1 = n[0];
                var cy1 = n[1];
                dx = n[2];
                dy = n[3];
                addCurve(ctx, x + (cx1 - x) * math_1.quadraticRatio, y + (cy1 - y) * math_1.quadraticRatio, dx + (cx1 - dx) * math_1.quadraticRatio, dy + (cy1 - dy) * math_1.quadraticRatio, dx, dy);
                ctx.cx = cx1;
                ctx.cy = cy1;
            }
            else if (command === constants_1.T) {
                dx = n[0];
                dy = n[1];
                if (ctx.lc === constants_1.Q || ctx.lc === constants_1.T) {
                    x1 = x + (x * 2 - ctx.cx - x) * math_1.quadraticRatio;
                    y1 = y + (y * 2 - ctx.cy - y) * math_1.quadraticRatio;
                    x2 = dx + (x * 2 - ctx.cx - dx) * math_1.quadraticRatio;
                    y2 = dy + (y * 2 - ctx.cy - dy) * math_1.quadraticRatio;
                }
                else {
                    x1 = x2 = x;
                    y1 = y2 = y;
                }
                addCurve(ctx, x1, y1, x2, y2, dx, dy);
                ctx.cx = x2;
                ctx.cy = y2;
            }
            else if (command === constants_1.A) {
                var beziers = arcToCurve_1.arcToCurve(x, y, n[0], n[1], n[2], n[3], n[4], n[5], n[6]);
                for (var j = 0; j < beziers.length; j += 6) {
                    addCurve(ctx, beziers[j], beziers[j + 1], beziers[j + 2], beziers[j + 3], beziers[j + 4], beziers[j + 5]);
                }
            }
            else {
                errors_1.raiseError(ctx.c, ' is not supported');
            }
            k += maxLength;
        } while (k < t2.length);
    }
    return ctx.s;
}
exports.parsePoints = parsePoints;
