Object.defineProperty(exports, "__esModule", { value: true });
var fillSegments_1 = require("./fillSegments");
var normalizePoints_1 = require("./normalizePoints");
var fillPoints_1 = require("./fillPoints");
var constants_1 = require("../constants");
var errors_1 = require("../utilities/errors");
function sizeDesc(a, b) {
    return b.p - a.p;
}
function normalizePaths(left, right, options) {
    var leftPath = getSortedSegments(left);
    var rightPath = getSortedSegments(right);
    var origin = options.origin;
    var ox = origin.x;
    var oy = origin.y;
    var absolute = origin.absolute;
    if (leftPath.length !== rightPath.length) {
        if (options.optimize === constants_1.FILL) {
            fillSegments_1.fillSegments(leftPath, rightPath, options.origin);
        }
        else {
            errors_1.raiseError('optimize:none requires equal lengths');
        }
    }
    var matrix = Array(2);
    matrix[0] = leftPath.map(toPoints);
    matrix[1] = rightPath.map(toPoints);
    if (options.optimize !== constants_1.NONE) {
        for (var i = 0; i < leftPath.length; i++) {
            var ls = leftPath[i];
            var rs = rightPath[i];
            normalizePoints_1.normalizePoints(absolute ? ox : ls.x + ls.w * ox, absolute ? oy : ls.y + ls.h * oy, matrix[0][i]);
            normalizePoints_1.normalizePoints(absolute ? ox : rs.x + rs.w * ox, absolute ? oy : rs.y + rs.h * oy, matrix[1][i]);
        }
    }
    if (options.optimize === constants_1.FILL) {
        fillPoints_1.fillPoints(matrix, options.addPoints * 6);
    }
    return matrix;
}
exports.normalizePaths = normalizePaths;
function getSortedSegments(path) {
    return path.data.slice().sort(sizeDesc);
}
function toPoints(p) {
    return p.d;
}
