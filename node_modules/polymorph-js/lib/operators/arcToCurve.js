Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = require("../utilities/math");
var _120 = math_1.PI * 120 / 180;
var PI2 = math_1.PI * 2;
function arcToCurve(x1, y1, rx, ry, angle, large, sweep, dx, dy, f1, f2, cx, cy) {
    if (rx <= 0 || ry <= 0) {
        return [x1, y1, dx, dy, dx, dy];
    }
    var rad = math_1.PI / 180 * (+angle || 0);
    var cosrad = math_1.cos(rad);
    var sinrad = math_1.sin(rad);
    var recursive = !!f1;
    if (!recursive) {
        var x1old = x1;
        var dxold = dx;
        x1 = x1old * cosrad - y1 * -sinrad;
        y1 = x1old * -sinrad + y1 * cosrad;
        dx = dxold * cosrad - dy * -sinrad;
        dy = dxold * -sinrad + dy * cosrad;
        var x = (x1 - dx) / 2;
        var y = (y1 - dy) / 2;
        var h = x * x / (rx * rx) + y * y / (ry * ry);
        if (h > 1) {
            h = math_1.sqrt(h);
            rx = h * rx;
            ry = h * ry;
        }
        var k = (large === sweep ? -1 : 1) *
            math_1.sqrt(math_1.abs((rx * rx * ry * ry - rx * rx * y * y - ry * ry * x * x) / (rx * rx * y * y + ry * ry * x * x)));
        cx = k * rx * y / ry + (x1 + dx) / 2;
        cy = k * -ry * x / rx + (y1 + dy) / 2;
        f1 = math_1.asin((y1 - cy) / ry);
        f2 = math_1.asin((dy - cy) / ry);
        if (x1 < cx) {
            f1 = math_1.PI - f1;
        }
        if (dx < cx) {
            f2 = math_1.PI - f2;
        }
        if (f1 < 0) {
            f1 += PI2;
        }
        if (f2 < 0) {
            f2 += PI2;
        }
        if (sweep && f1 > f2) {
            f1 -= PI2;
        }
        if (!sweep && f2 > f1) {
            f2 -= PI2;
        }
    }
    var res;
    if (math_1.abs(f2 - f1) > _120) {
        var f2old = f2;
        var x2old = dx;
        var y2old = dy;
        f2 = f1 + _120 * (sweep && f2 > f1 ? 1 : -1);
        dx = cx + rx * math_1.cos(f2);
        dy = cy + ry * math_1.sin(f2);
        res = arcToCurve(dx, dy, rx, ry, angle, 0, sweep, x2old, y2old, f2, f2old, cx, cy);
    }
    else {
        res = [];
    }
    var t = 4 / 3 * math_1.tan((f2 - f1) / 4);
    res.splice(0, 0, 2 * x1 - (x1 + t * rx * math_1.sin(f1)), 2 * y1 - (y1 - t * ry * math_1.cos(f1)), dx + t * rx * math_1.sin(f2), dy - t * ry * math_1.cos(f2), dx, dy);
    if (!recursive) {
        for (var i = 0, ilen = res.length; i < ilen; i += 2) {
            var xt = res[i], yt = res[i + 1];
            res[i] = xt * cosrad - yt * sinrad;
            res[i + 1] = xt * sinrad + yt * cosrad;
        }
    }
    return res;
}
exports.arcToCurve = arcToCurve;
